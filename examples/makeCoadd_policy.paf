#<? cfg paf policy ?>
#
# default policy for makeCoadd.py example

# save intermediate images?
saveDebugImages: true

# pixels with these mask plane bits other than these are omitted from the coadd
allowedMaskPlanes: "BAD SAT INTRP"

# warp and psf-match exposures to match the reference exposure?
# if false then:
# * all exposures are assumed to match the reference in WCS, size and PSF
# * all other policy entries are ignored except allowedMaskPlanes and saveDebugImages
# * the coadd matches the reference exposure's WCS and size
doWarpExposures: true

# resolution of coadd/input images along x and y; larger values produce more pixels in the coadd
resolutionFactor: 1.0

# name of warping kernel, e.g. lanczos4 or bilinear
warpingKernelName: lanczos3

psfMatchPolicy: {
    ####################################
    # RUNNING DETECTION TO FIND GOOD FOOTPRINTS
    #
    ######
    # Minimum number of pixels in an acceptible Footprint
    #
    fpNpixMin: 5
    
    ######
    # Maximum number of pixels in an acceptible Footprint
    #
    # Too big and the subsequent convolutions become unwieldy 
    #
    fpNpixMax: 500
    
    ######
    # Grow footprint by this many units of the Kernel size
    #
    # Note : this number should be no smaller than 1.5.  Otherwise there
    # are too few pixels to accurately constrain the background and the
    # Kernel sum.  A value of 2.0 is slightly conservative in that the
    # quality of the Kernels should be better / more stable, but will take
    # about twice as long to calcuate.  If you look at the plot of Kernel
    # sum vs. this variable, kSum does not converge until at least 1.5.
    #
    fpGrowKsize: 2.0
    
    ######
    # Threshold in Sigma or Signal detection?
    #
    # Allowed values : value, stdev, variance
    #
    detThresholdType: "stdev"
    
    ######
    # Threshold 
    #
    # Initial detection threshold (if high, this is for debugging)
    #
    # For standard processing a value like 10 would be acceptable
    # 
    detThreshold: 5.0
    
    ######
    # Minimum number of clean candidates in the image
    #
    minCleanFp: 30
    
    ######
    # How do you change the detection threshold if minCleanFp
    # not found
    #
    detThresholdScaling: 0.5
    
    
    ####################################
    # BASIS SET FOR KERNEL FITTING
    #
    ######
    # Type of basis set for PSF matching kernel
    #
    # Options are : delta-function, alard-lupton
    #
    # If alard-lupton is used, the first term will have no spatial
    # variation and the kernel sum will be conserved.  If delta-function
    # is used, you have the option to "useRegularization", and might also
    # want to seriously consider "usePcaForSpatialKernel" which will also
    # enable kernel sum conservation for the delta function kernels.
    #
    # NOTE : if "alard-lupton" you likely want to turn off
    #        "usePcaForSpatialKernel" down below
    #
    kernelBasisSet: "alard-lupton"
    
    ######
    # Size of the convolution kernel
    #
    # For delta function kernels there are kernelRows.x.kernelCols bases
    # For alard lupton kernel, the half width is kernelRows//2, kernelCols//2
    #
    kernelRows: 19
    kernelCols: 19
    
    ######
    # Default Alard-Lupton Parameters
    # 
    # Note that the widths are in sigma, not FWHM
    # len(alardSigGauss) and len(alardDegGauss) must equal alardNGauss
    #
    alardNGauss:   3
    alardSigGauss: 0.7 1.5 3.0
    alardDegGauss: 4   3   2    
    
    ######
    # Regularization used with delta-function kernel basis set to enfore
    # smoothness and self-similarity
    #
    # order      : Which derivative you expect to be smooth (e.g. for order=0, first derivative is penalized)
    # boundary   : 0 = unwrapped, 1 = wrapped, 2 = order-tapered ('order' is highest used) 
    # difference : 0 = forward, 1 = central
    # scaling    : Fraction of the default lambda calculation (N.R. 18.5.8) to use; strength of regularization
    #
    useRegularization: true
    regularizationOrder: 2
    regularizationBoundary: 1
    regularizationDifference: 0
    regularizationScaling: 0.001
    
    
    
    ####################################
    # KERNEL QUALITY CONTROL
    #
    ######
    # Rejects objects with deviant Kernel Sums
    #
    #
    maxKsumIterations: 5
    maxKsumSigma: 3.0
    
    ######
    # Rejects objects with bad difference image quality
    #
    # This is used as a proxy for the quality of the kernel.  We look at
    # both the mean value of the residuals in the difference image
    # (normalized by the noise; expectation value is 0.0) as well as the
    # width of the distribution (expectation value 1.0)
    #
    # Maximum diffim average of (residual/noise) for an acceptable Kernel
    #
    candidateResidualMeanMax: 0.25
    
    ######
    # Maximum diffim standard deviation of (residual/noise) for an acceptable Kernel
    #
    candidateResidualStdMax: 1.25
    
    ######
    # What types of sigma clipping to enable
    #
    # If you want sigma clipping at each step along the way, it should be:
    #   singleKernelClipping:  true
    #   kernelSumClipping:     true
    #   spatialKernelClipping: true
    #
    # If you only care about the final spatial kernel quality it should be:
    #   singleKernelClipping:  false
    #   kernelSumClipping:     false
    #   spatialKernelClipping: true
    # In this case you might want to consider upping "maxSpatialIterations" below
    #
    singleKernelClipping:  true
    kernelSumClipping:     true
    spatialKernelClipping: false
    
    
    
    ####################################
    # SINGLE KERNEL FITTING AROUND 1 SOURCE
    #
    ######
    # Remake single kernel using better variance estimate after first pass?
    #
    # Primarily useful when convolving a single-depth template image,
    # otherwise not necessary
    #
    iterateSingleKernel: false
    
    ######
    # Use constant variance weighting in single kernel fitting?  
    #
    # In some cases this is better for bright star residuals
    #
    constantVarianceWeighting: false
    
    ######
    # Calculate kernel and background uncertainties for each object?
    #
    # Comes from inverse of the covariance matrix
    # NOTE: Regularization can cause this step problems
    #
    calculateKernelUncertainty: false
    
    
    
    ####################################
    # SPATIAL KERNEL FITTING
    #
    ######
    # Order of kernel and background spatial variation
    #
    # If you are using a large image, spatialKernelOrder=0, and a constant
    # kernel is a bad approximation, you probably want to use the
    # following configuration for the sigma clipping above:
    #
    #   singleKernelClipping:  true
    #   kernelSumClipping:     true
    #   spatialKernelClipping: false
    # 
    spatialKernelOrder: 0
    spatialBgOrder:     1
    
    ######
    # Do we subtract off the differential background independent of ip_diffim?
    # 
    #backgroundPolicy: {
    #    # how to interpolate the background values
    #    algorithm:  "NATURAL_SPLINE" 
    #    # how large regions of the sky should be used for each background point
    #    binsize:    128
    #}
    
    #####
    # Chops up the image into cells of sizeCellX x sizeCellY pixels
    #
    # Used to initialize afwMath::SpatialCellSet class 
    #
    sizeCellX: 256
    sizeCellY: 256
    
    ######
    # Number of stars to use in each SpatialCell cell
    #
    nStarPerCell: 1
    
    ######
    # Number of iterations to reject bad footprints in the spatial fitting
    #
    maxSpatialIterations: 5
    
    ######
    # Do we use PCA to reduce the dimensionality of the basis sets?
    #
    # This is particularly useful for delta-function kernels;
    # functionally, all the Cells have their raw kernels determined, we
    # run a PCA on these Kernels, and then re-fit the Cells using the
    # eigenKernels which are then fit for spatially using the same
    # technique as for the non-PCA delta-function and Alard-Lupton kernels
    # 
    # If this option is used, the first term (mean kernel) will have no
    # spatial variation and the kernel sum will be conserved
    #
    usePcaForSpatialKernel: true
    
    ######
    # How many principal components do you use in the decomposition?
    #
    # Note : this is defined to be the number to use *_in addition to_*
    # the mean kernel, so in total you use N+1 basis functions for the
    # decomposition.
    # 
    numPrincipalComponents: 4
    
    ######
    # At what fraction of the eigenvalues do you cut off the expansion?
    #
    # This currently not implemented
    #
    fracEigenVal : 0.95
}
